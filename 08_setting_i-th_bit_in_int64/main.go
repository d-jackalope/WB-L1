package main

import "fmt"

// Дана переменная int64. Разработать программу которая устанавливает i-й бит в 1 или 0.

// если ввести позицию бита большую, чем 63, то исходное число останется преждним, тк если сделать такой сдвиг влево, то это приведет к "выбрасыванию" старших битов из-за пределов размера int64.
// В go integer-типы представляются с использованием дополнительного кода, это означает что если изменить битовый знак (для int64 - 63 бит и тд), то
// изменение знака числа в дополнительном коде приведет к изменению всего его двоичного представления.
// Например: "-100 63 0" - изменит "-100" до "9223372036854775708"

func main() {
	fmt.Println("Введите число, позицию бита и значение бита (1 или 0)...")
	var num int64
	var bit, position uint8
	fmt.Scan(&num, &position, &bit)

	// создание маски путем сдвига бита на позицию
	var mask int64 = 1 << position
	fmt.Printf("%064b\n", num)
	fmt.Printf("%064b\n", mask)

	// проверка значения бита для установки в число
	switch bit {
	case 1:
		num |= mask // изменение бита в числе путем дизъюнкции (ИЛИ), в i-позиции будет "1" вне зависимости от предыдущего значения
		fmt.Printf("%064b\n", num)
		fmt.Printf("%v-бит был изменен на 1, новое число: %v\n", position, num)

	case 0:
		// Cброс бита в числе путем конъюнкции и инверсированной маски (И НЕТ).
		// Таким образом все значения в num останутся прежними, кроме бита, который нужно сбросить вне зависимости от его прежнего значения
		num &^= mask
		fmt.Printf("%064b \n", num)
		fmt.Printf("%v-бит был сброшен, новое число: %v\n", position, num)

	default:
		fmt.Println("Неверное значение бита")
	}

}
