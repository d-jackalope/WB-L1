package main

import (
	"fmt"
	"os"
	"os/signal"
	"sync"
	"time"
)

// Реализовать постоянную запись данных в канал (главный поток).
// Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout.
// Необходима возможность выбора количества воркеров при старте.

// Программа должна завершаться по нажатию Ctrl+C.
// Выбрать и обосновать способ завершения работы всех воркеров.

func main() {
	fmt.Println("Введите количество воркеров...")
	var workers int
	fmt.Scan(&workers) // Счет кол-ва воркеров с ввода

	// Cоздание канала для сигнала завершения программы
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt)

	wg := sync.WaitGroup{} // Создание waitGroup для ожидания завершения всех горутин

	dataChan := make(chan int) // Канал для отправки данных
	// Создание воркеров
	for i := 1; i <= workers; i++ {
		wg.Add(1)                   // добавление каждой новой горутины в группу
		go worker(dataChan, &wg, i) // передача канала данных, указателя на waitGroup и номера воркера в функцию
	}

	count, last := 0, 0 // count - имитация данных, last - последнее число перед выключением программы
	for {
		select {
		case <-sigChan: // ожидание сигнала завершения
			fmt.Println("Завершение программы...")
			close(dataChan) // закрытие канала передачи данных, сигнал о завершении работы горутинам
			wg.Wait()       // ожидание корректного отключения горутин
			fmt.Println("Все воркеры остановлены")
			fmt.Println("Конечное число из main: ", last)
			os.Exit(0) // завершение с кодом 0
		default: // если сигнала нет, то по умолчанию отправляем данные
			// без короткой задержки у меня крашится VSCode (не при старте, а от длительной работы)
			// запуск через обычный терминал без time.Sleep - без проблем
			time.Sleep(time.Millisecond)
			dataChan <- count // отправка данных горутинам
			last = count
			count++ // изменение данных
		}
	}
}

func worker(dataChan <-chan int, wg *sync.WaitGroup, worker int) {
	last := 0 // последнее число с которым работал воркер, чисто для наглядности
	for {
		data, ok := <-dataChan // прием данных из канала c проверкой
		// при закрытии канала последними значениями приходят
		// data=нулевое значение для типа канала
		// ok=false - сигнал о том, что канал закрыт
		if !ok {
			fmt.Printf("Воркер %v закончил работу, последнее число %v\n", worker, last)
			wg.Done() // сигнал о завершении работы горутины
			return    // выход из функции
		}
		last = data
		fmt.Printf("%v из воркера %v\n", data, worker) // обработка данных
	}
}

// Обоснование способа завершения всех воркеров:
//	При получении сигнала о завершении работы программы, я закрываю канал передачи данных,
//	тем самым сигнализируя воркерам о том, что данных больше не будет.
//	Даже если в канале остались данные для обработки, то каналы работают по принципу FIFO (First-In-First-Out),
//  это означает что все данные перед сигналом завершения канала гарантированно обработаются,
//	и только потом воркер завершит свою работу, предварительно удалив себя из waitGroup.
//	Как только счетчик waitGroup достигнет нуля - программа окончательно завершится.
